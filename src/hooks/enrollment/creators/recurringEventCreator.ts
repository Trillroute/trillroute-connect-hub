
import { supabase } from '@/integrations/supabase/client';
import { v4 as uuidv4 } from 'uuid';
import { calculateEventDuration } from '../utils/durationCalculator';
import { fetchCourseDetails, fetchUserDetails } from '../utils/userDataFetcher';
import { EventMetadata } from '../types/calendarEventTypes';

export const createRecurringEvents = async (
  courseId: string,
  studentId: string,
  teacherId: string,
  additionalMetadata?: Record<string, any>,
  courseData?: any
): Promise<boolean> => {
  try {
    console.log('Creating recurring events for enrollment:', { courseId, studentId, teacherId, additionalMetadata });

    const eventDurationMinutes = await calculateEventDuration(courseId);
    const course = courseData || await fetchCourseDetails(courseId);

    if (!course) {
      console.error('Error fetching course details');
      return false;
    }

    const teacher = await fetchUserDetails(teacherId);
    const student = await fetchUserDetails(studentId);

    if (!teacher || !student) {
      console.error('Error fetching user details');
      return false;
    }

    // For solo courses with availability slot data, remove the slot and create events
    if (course.course_type === 'solo' && additionalMetadata?.availabilitySlotId) {
      console.log('Processing solo course enrollment with availability slot:', additionalMetadata.availabilitySlotId);
      
      // Remove the availability slot since it's now booked
      const { error: deleteError } = await supabase
        .from('user_availability')
        .delete()
        .eq('id', additionalMetadata.availabilitySlotId);

      if (deleteError) {
        console.error('Error removing availability slot:', deleteError);
        // Continue anyway - slot removal failure shouldn't block enrollment
      } else {
        console.log('Successfully removed availability slot:', additionalMetadata.availabilitySlotId);
      }

      // Create recurring events based on the slot timing
      const dayOfWeek = additionalMetadata.dayOfWeek;
      const startTime = additionalMetadata.startTime;
      const endTime = additionalMetadata.endTime;

      if (typeof dayOfWeek === 'number' && startTime && endTime) {
        const eventsToCreate = [];
        const startDate = new Date();
        
        // Find the next occurrence of the specified day of week
        const daysUntilNext = (dayOfWeek - startDate.getDay() + 7) % 7;
        if (daysUntilNext === 0 && startDate.getHours() > 12) {
          // If it's the same day but already afternoon, schedule for next week
          startDate.setDate(startDate.getDate() + 7);
        } else {
          startDate.setDate(startDate.getDate() + daysUntilNext);
        }

        // Parse the time from HH:MM format
        const [startHour, startMinute] = startTime.split(':').map(Number);
        const [endHour, endMinute] = endTime.split(':').map(Number);

        // Create events for the next 12 weeks (3 months)
        for (let week = 0; week < 12; week++) {
          const eventDate = new Date(startDate);
          eventDate.setDate(startDate.getDate() + (week * 7));
          eventDate.setHours(startHour, startMinute, 0, 0);

          const eventEndDate = new Date(eventDate);
          eventEndDate.setHours(endHour, endMinute, 0, 0);

          const baseMetadata: EventMetadata = {
            courseId,
            studentId,
            teacherId,
            courseType: course.course_type,
            courseTitle: course.title,
            courseSkill: course.skill,
            courseLevel: course.level,
            studentName: `${student.first_name} ${student.last_name}`,
            teacherName: `${teacher.first_name} ${teacher.last_name}`,
            isAutoGenerated: true,
            isRecurring: true,
            weekNumber: week + 1,
            durationMinutes: eventDurationMinutes,
            originalSlotId: additionalMetadata.availabilitySlotId
          };

          const teacherEvent = {
            id: uuidv4(),
            user_id: teacherId,
            event_type: 'class',
            title: `${course.title} - ${student.first_name} ${student.last_name}`,
            description: `Solo class with student ${student.first_name} ${student.last_name}. Course: ${course.title}`,
            start_time: eventDate.toISOString(),
            end_time: eventEndDate.toISOString(),
            metadata: {
              ...baseMetadata,
              // Store filter-friendly values at the root level of metadata
              course_id: courseId,
              student_id: studentId,
              teacher_id: teacherId,
              skill_id: course.skill,
              level_id: course.level
            }
          };

          const studentEvent = {
            id: uuidv4(),
            user_id: studentId,
            event_type: 'class',
            title: `${course.title} - with ${teacher.first_name} ${teacher.last_name}`,
            description: `Solo class with teacher ${teacher.first_name} ${teacher.last_name}. Course: ${course.title}`,
            start_time: eventDate.toISOString(),
            end_time: eventEndDate.toISOString(),
            metadata: {
              ...baseMetadata,
              // Store filter-friendly values at the root level of metadata
              course_id: courseId,
              student_id: studentId,
              teacher_id: teacherId,
              skill_id: course.skill,
              level_id: course.level
            }
          };

          eventsToCreate.push(teacherEvent, studentEvent);
        }

        console.log('About to insert', eventsToCreate.length, 'recurring events');

        const { error: insertError } = await supabase
          .from('user_events')
          .insert(eventsToCreate);

        if (insertError) {
          console.error('Error creating calendar events:', insertError);
          return false;
        }

        console.log(`Successfully created ${eventsToCreate.length} calendar events for solo course enrollment`);
        return true;
      } else {
        console.error('Invalid slot timing data:', { dayOfWeek, startTime, endTime });
        return false;
      }
    }

    // For other recurring courses without specific slot data, use default logic
    console.log('Creating default recurring events without slot removal');
    return true;

  } catch (error) {
    console.error('Error in createRecurringEvents:', error);
    return false;
  }
};
